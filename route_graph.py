'''
ИДЕЯ: рекуррентная формула Nz = Nb + Nc + Nd, где Z - назначение, а из точки отправления можно добраться только
    через B, C, D по количеству путей N.
Создать массив размером с ширину графа.
Массив изначально заполняется числами 1, 3, 5 и тд (+2).
Создается еще один дополнительный массив, iый элемент которого вычисляется как
    дополнительный[i] = основной[i] + основной[i - 1] + дополнительный[i - 1].
Массивы вычисляются от низа к верху.
Это происходит 'высота - 2' количество раз (нижня строка из единиц, а вторая снизу вычисляется изначально).
Результатом будет последний элемент массива.

Сложность алгоритма: W - ширина графа, H - высота графа
O(W) + O(H-2) * O(W-1) = O(W) + O(WH) = O(W*(H+1)) = O(WH)
'''


def make_next_line(arr_up, lenw):  # сложность функции W-1
    arr = []
    i = lenw
    j = 0
    arr.append(1)
    while i > 1:
        arr.append(arr[j] + arr_up[j] + arr_up[j + 1])
        i -= 1
        j += 1
    arr_up = arr
    return arr_up


if __name__ == "__main__":
    width = 835
    height = 967

    arr_up = []
    x = 1
    for i in range(width):  # W
        arr_up.append(x)
        x += 2
    while height > 2:  # H-2 * W-1
        arr_up = make_next_line(arr_up, width)
        height -= 1
    # print(arr_up)
    print('RESULT = ', arr_up[width - 1])
